# 카드 매칭 게임 - 발표 대본

---

## 1. 프로젝트 개요

안녕하세요. 지금부터 카드 매칭 게임의 기술적인 부분을 설명드리겠습니다.

먼저 프로젝트 구조를 보시면, 크게 5개의 디렉토리로 나뉘어 있습니다.

- **core** 디렉토리에는 Card와 GameState라는 데이터 모델이 있고요
- **logic** 디렉토리에는 CardManager와 GameManager라는 비즈니스 로직이 있습니다
- **rendering** 디렉토리에는 화면을 그리는 렌더러들이 있고요
- **utils** 디렉토리에는 공통으로 사용하는 유틸리티들이 있습니다
- 그리고 **screens** 디렉토리에는 시작화면, 게임화면, 결과화면 같은 화면 컴포넌트들이 있습니다

총 19개의 JavaScript 파일로 구성되어 있습니다.

---

## 2. 기술 스택

기술 스택을 설명드리겠습니다.

메인 프레임워크로는 **p5.js 1.7.0**을 사용했습니다. p5.js는 캔버스 기반의 그래픽 라이브러리인데요, 게임 개발에 적합한 몇 가지 특징이 있습니다.

첫째, **DOM 조작 없이 캔버스에 직접 그리기** 때문에 부드러운 애니메이션이 가능합니다.
둘째, **60fps draw 루프**가 내장되어 있어서 게임 루프 구현이 간단합니다.
셋째, 도형, 이미지, 변환, 색상 등 **풍부한 그래픽 API**를 제공합니다.

언어는 **Vanilla JavaScript ES6+**를 사용했습니다. React나 Vue 같은 외부 프레임워크 없이 순수 자바스크립트로만 구현했습니다.

디자인 패턴으로는 **Observer 패턴**을 적용해서 컴포넌트 간 느슨한 결합을 구현했고요, 전체적인 구조는 **계층형 아키텍처**를 따르고 있습니다.

---

## 3. 아키텍처 설계

### 3.1 계층형 아키텍처

아키텍처 설계를 설명드리겠습니다.

이 프로젝트는 **계층형 아키텍처**, 영어로 Layered Architecture를 적용했습니다. 화면의 다이어그램을 보시면 5개의 계층이 색상별로 구분되어 있습니다.

맨 위 **파란색 Presentation Layer**가 있습니다. main.js가 여기에 해당하고, p5.js의 setup, draw, 이벤트 처리를 담당합니다.

그 아래 **주황색 Rendering Layer**가 있습니다. UIRenderer, CardRenderer, ParticleSystem이 여기에 속하고요, 실제로 화면에 그리는 역할을 합니다.

그 다음 **보라색 Logic Layer**입니다. GameManager와 CardManager가 있고, 게임 규칙과 매칭 로직, 타이머 등을 처리합니다.

그 아래 **초록색 Core Layer**입니다. GameState와 Card 클래스가 있고요, 게임의 데이터 모델과 상태를 관리합니다.

마지막으로 **분홍색 Utils Layer**입니다. EventEmitter, GridCalculator, ArrayUtils 같은 공통 유틸리티들이 있습니다.

다이어그램의 **화살표 방향**을 주목해 주세요. 모두 위에서 아래로 향하고 있습니다. 이것이 **단방향 의존성**의 핵심입니다. 위 계층은 아래 계층만 참조할 수 있습니다.

### 3.2 계층 분리의 장점

이렇게 계층을 분리하면 몇 가지 장점이 있습니다.

첫째, **관심사 분리**입니다. 각 계층이 하나의 책임만 담당하기 때문에 코드가 명확해집니다.

둘째, **테스트 용이성**입니다. 계층별로 독립적인 테스트가 가능합니다.

셋째, **유지보수성**입니다. 한 계층을 변경해도 다른 계층에 미치는 영향이 최소화됩니다.

넷째, **단방향 의존성**입니다. 위 계층이 아래 계층만 참조하기 때문에 의존성 관리가 깔끔해집니다.

### 3.3 적용된 디자인 패턴

이 프로젝트에 적용된 디자인 패턴들을 정리하면요,

**Observer 패턴**은 EventEmitter에 적용했습니다. 컴포넌트 간 느슨한 결합을 위해서입니다.

**Singleton 패턴**은 gameState와 gameManager에 적용했습니다. 전역에서 유일한 인스턴스를 사용합니다.

**Factory 패턴**은 CardManager의 createDeck 메서드에 적용했습니다. 난이도에 따라 다른 카드 덱을 생성합니다.

**Strategy 패턴**은 Screen 컴포넌트들에 적용했습니다. 화면별로 다른 렌더링 전략을 사용합니다.

**State 패턴**은 GameState의 phase에 적용했습니다. 게임의 상태 머신을 구현합니다.

### 3.4 파일 의존성

다음 다이어그램은 주요 파일들 간의 **참조 관계**를 보여줍니다.

왼쪽의 **main.js**가 진입점입니다. 여기서 GameManager, GameState, 그리고 각종 렌더러들을 참조합니다.

**GameManager**는 GameState를 사용하고, CardManager를 통해 카드를 생성합니다. 점선 화살표는 GameManager가 **EventEmitter를 상속**한다는 것을 나타냅니다.

**CardManager**는 Card 객체를 생성하고, GridCalculator와 ArrayUtils를 사용합니다.

이 다이어그램을 보시면 **의존성이 한 방향으로만** 흐르는 것을 확인할 수 있습니다. 이것이 계층형 아키텍처의 핵심입니다.

---

## 4. Core Layer - 데이터 모델

이제 각 계층을 자세히 살펴보겠습니다. 먼저 Core Layer입니다.

화면의 **클래스 다이어그램**을 보시면 주요 클래스들의 관계가 나타나 있습니다.

**EventEmitter**가 맨 위에 있고, **GameManager**가 이를 상속합니다. 이 상속 관계 덕분에 GameManager가 이벤트를 발행할 수 있습니다.

GameManager는 **GameState**와 **CardManager**를 "uses" 관계로 사용합니다. CardManager는 **Card** 객체를 "creates" 관계로 생성하고, GameState는 Card 배열을 "contains" 관계로 포함합니다.

각 클래스 박스 안에는 주요 속성과 메서드가 표시되어 있습니다.

### 4.1 Card 클래스

**Card 클래스**는 개별 카드의 데이터를 담당합니다.

생성자에서 **불변 속성**과 **가변 속성**을 분리했습니다. id와 imagePath는 한 번 설정되면 바뀌지 않는 불변 속성이고요, isFlipped나 isMatched 같은 상태는 게임 중에 변할 수 있는 가변 속성입니다.

모든 속성은 **private**으로 선언하고, **getter**를 통해서만 외부에서 접근할 수 있게 했습니다. 이렇게 캡슐화를 적용하면 외부에서 직접 상태를 변경하는 것을 막을 수 있습니다.

카드 클래스에는 몇 가지 **비즈니스 로직**도 포함되어 있습니다.

`canFlip()` 메서드는 카드를 뒤집을 수 있는지 확인합니다. 이미 매칭된 카드, 애니메이션 중인 카드, 이미 뒤집힌 카드는 뒤집을 수 없습니다.

`isMatchWith(other)` 메서드는 다른 카드와 매칭되는지 확인합니다. 같은 id를 가진 카드끼리 매칭됩니다.

`contains(mx, my)` 메서드는 마우스 좌표가 카드 영역 안에 있는지 확인합니다. 클릭 감지에 사용됩니다.

### 4.2 GameState 클래스

**GameState 클래스**는 게임의 전체 상태를 관리합니다.

핵심은 **상태 머신**입니다. `GAME_PHASE`라는 상수로 정의된 5가지 상태가 있습니다.
- START: 시작 화면
- DIFFICULTY: 난이도 선택 화면
- PREVIEW: 카드 미리보기
- PLAYING: 게임 진행 중
- RESULT: 결과 화면

현재 phase가 무엇인지에 따라 화면이 다르게 렌더링됩니다.

GameState는 **단일 진실 공급원**, 영어로 Single Source of Truth 역할을 합니다. 게임의 모든 상태 정보가 이 클래스 하나에 집중되어 있습니다. 카드 배열, 선택된 카드, 점수, 남은 시간, 하트, 콤보 등 모든 정보가 여기에 있습니다.

상태를 변경하는 메서드들도 있습니다. `recordMatch()`는 매칭 성공 시 호출되어 점수와 콤보를 업데이트하고요, `recordMismatch()`는 매칭 실패 시 호출되어 콤보를 초기화하고 하트와 시간을 감소시킵니다.

---

## 5. Logic Layer - 비즈니스 로직

### 5.1 CardManager - 카드 생성

다음은 Logic Layer입니다.

**CardManager**는 카드 생성과 관리를 담당합니다.

핵심 메서드는 `createDeck()`입니다. 이 메서드는 **Factory 패턴**을 적용한 것으로, 난이도에 따라 다른 구성의 카드 덱을 생성합니다.

화면의 **흐름도**를 보시면 `createDeck()` 내부 동작이 나타나 있습니다.

먼저 **matchingRule 분기**가 있습니다. 2면 `_generateCardPairs()`로 같은 ID 카드 2장씩, 3이면 `_generateCardSets()`로 3장씩 생성합니다.

그 다음 **히든 카드 분기**입니다. 활성화되어 있으면 히든 카드 쌍을 추가합니다.

그 다음 **폭탄 카드 분기**입니다. 설정이 있으면 폭탄 카드를 추가합니다.

마지막으로 **셔플과 좌표 할당**입니다. ArrayUtils.shuffle()로 카드를 섞고, GridCalculator로 각 카드의 위치를 계산합니다.

이 흐름도를 보시면 난이도 설정에 따라 **어떤 경로로 카드가 생성되는지** 한눈에 파악할 수 있습니다.

### 5.2 GameManager - 게임 로직

**GameManager**는 게임의 전체 흐름을 제어합니다.

중요한 점은 GameManager가 **EventEmitter를 상속**한다는 것입니다. 이렇게 하면 이벤트 기반 통신이 가능해집니다.

`handleClick()` 메서드를 보시면, 카드 클릭 처리 로직이 있습니다.

먼저 현재 게임 중인지 확인하고, 클릭한 위치에 카드가 있는지 찾습니다. 카드가 있으면 canFlip()으로 뒤집을 수 있는지 확인합니다.

폭탄 카드를 클릭했으면 `_handleBombCard()`로 폭탄 처리를 하고요, 일반 카드면 애니메이션을 실행하고 이벤트를 발행합니다.

그 다음 첫 번째 카드인지, 두 번째 카드인지, 세 번째 카드인지에 따라 다르게 처리합니다. 2장 매칭이면 두 번째 카드 선택 후 매칭을 검사하고요, 3장 매칭이면 세 번째 카드 선택 후 매칭을 검사합니다.

`_checkMatch()` 메서드에서 실제 매칭 여부를 판단하고, 성공이면 `_handleMatch()`, 실패면 `_handleMismatch()`를 호출합니다.

**핵심 포인트**는 GameManager가 상태 변경과 이벤트 발행만 담당한다는 것입니다. 실제 렌더링이나 사운드 재생은 이벤트를 구독하는 쪽에서 처리합니다. 이것이 Observer 패턴의 핵심입니다.

---

## 6. Rendering Layer - 화면 렌더링

### 6.1 main.js - p5.js 통합

이제 Rendering Layer를 설명드리겠습니다.

**main.js**는 p5.js와의 통합 지점입니다.

p5.js의 `setup()` 함수는 프로그램 시작 시 한 번만 실행됩니다. 여기서 캔버스를 생성하고, 모든 인스턴스를 초기화하고, 이벤트 리스너를 등록합니다.

p5.js의 `draw()` 함수는 매 프레임, 즉 초당 60번 실행됩니다. 여기서 현재 게임 상태에 따라 다른 화면을 그립니다. switch문으로 gameState.phase를 확인해서 START면 시작 화면, DIFFICULTY면 난이도 선택 화면, PLAYING이면 게임 화면, RESULT면 결과 화면을 그립니다.

`mouseClicked()` 함수는 마우스 클릭 시 호출됩니다. 역시 현재 상태에 따라 다른 처리를 합니다.

### 6.2 이벤트 리스너 설정

`setupGameCallbacks()` 함수에서 GameManager의 이벤트들을 구독합니다.

예를 들어 'match:success' 이벤트를 구독하면, 매칭 성공 시 다음 작업들이 실행됩니다:
- uiRenderer로 성공 메시지 표시
- cardRenderer로 매칭 애니메이션 실행
- soundManager로 효과음 재생
- particleSystem으로 파티클 효과 생성

이렇게 하면 GameManager는 렌더링 코드를 전혀 모르는 상태로 동작할 수 있습니다. 새로운 효과를 추가하고 싶으면 여기에 리스너만 추가하면 됩니다. GameManager 코드는 수정할 필요가 없습니다.

### 6.3 CardRenderer - 카드 렌더링

**CardRenderer**는 카드를 화면에 그리는 역할을 합니다.

`drawCard()` 메서드가 핵심입니다. 각 카드의 상태에 따라 앞면 또는 뒷면을 그리고, 호버 효과와 애니메이션을 적용합니다.

**카드 뒤집기 애니메이션**이 특히 재미있는 부분입니다.

`animateFlip()` 메서드를 보시면, 실제로 카드가 3D로 회전하는 것이 아니라 **X축 스케일을 변화**시켜서 뒤집히는 것처럼 보이게 합니다.

`cos(angle)`의 값이 1에서 0으로, 다시 0에서 1로 변하는 것을 이용합니다. progress가 0.5일 때, 즉 정확히 절반 지점에서 카드의 앞면과 뒷면을 전환합니다. 시각적으로는 카드가 옆으로 회전하다가 뒤집히는 것처럼 보입니다.

p5.js의 `push()`, `translate()`, `scale()`, `pop()` 함수들을 사용해서 변환을 적용합니다.

---

## 7. Utils Layer - 유틸리티

### 7.1 GridCalculator

다음은 Utils Layer입니다.

**GridCalculator**는 카드 그리드의 좌표를 계산합니다.

`calculateStartPosition()`은 그리드가 캔버스 중앙에 오도록 시작 위치를 계산합니다. 전체 그리드의 너비와 높이를 구한 다음, 캔버스 크기에서 빼고 2로 나눠서 중앙 정렬합니다.

`getCardPosition()`은 인덱스를 받아서 실제 좌표를 반환합니다. 열과 행을 계산하고, 카드 크기와 간격을 곱해서 최종 좌표를 구합니다.

### 7.2 ArrayUtils

**ArrayUtils**에는 배열 관련 유틸리티가 있습니다.

가장 중요한 것은 `shuffle()` 메서드입니다. **Fisher-Yates 알고리즘**을 사용합니다.

이 알고리즘의 특징은 첫째, **O(n) 시간 복잡도**로 효율적이고요, 둘째, **균등한 분포**를 보장합니다. 모든 순열이 동일한 확률로 나타납니다.

또한 **불변성**을 유지합니다. 원본 배열을 변경하지 않고 복사본을 만들어서 셔플합니다. 이렇게 하면 예기치 않은 부작용을 방지할 수 있습니다.

---

## 8. 이벤트 시스템 (EventEmitter)

### 8.1 Observer 패턴 구현

**EventEmitter**는 Observer 패턴을 구현한 클래스입니다.

내부적으로 `_events`라는 Map을 가지고 있습니다. key는 이벤트 이름이고, value는 리스너 함수들의 Set입니다.

`on(event, callback)`은 이벤트를 구독합니다. 해당 이벤트의 리스너 Set에 콜백을 추가합니다.

`off(event, callback)`은 구독을 해제합니다. 리스너 Set에서 콜백을 제거합니다.

`once(event, callback)`는 한 번만 실행되는 리스너를 등록합니다. 내부적으로 래퍼 함수를 만들어서 실행 후 자동으로 off를 호출합니다.

`emit(event, ...args)`은 이벤트를 발행합니다. 해당 이벤트의 모든 리스너에게 데이터를 전달하면서 호출합니다.

### 8.2 에러 격리

`emit()` 메서드에서 중요한 부분이 있습니다. 각 리스너 호출을 **try-catch**로 감싸고 있습니다.

이렇게 하면 **한 리스너에서 에러가 발생해도 다른 리스너에는 영향을 주지 않습니다.** 예를 들어 사운드 재생에서 에러가 나도 파티클 효과는 정상적으로 실행됩니다.

### 8.3 이벤트 흐름 시퀀스

화면의 **시퀀스 다이어그램**을 보시면 이벤트가 어떻게 전파되는지 확인할 수 있습니다.

왼쪽에서 **사용자**가 카드를 클릭합니다. **GameManager**가 이를 받아 **GameState**를 업데이트합니다. 그리고 `emit('match:success')`로 이벤트를 발행합니다.

여기서 중요한 점은 **점선 화살표**입니다. GameManager에서 main.js의 리스너로 이벤트가 전달되고, main.js가 CardRenderer, ParticleSystem, SoundManager를 각각 호출합니다.

이것이 **Observer 패턴의 핵심**입니다. GameManager는 렌더러나 사운드 코드를 전혀 모릅니다. 이벤트만 발행하면 됩니다.

### 느슨한 결합의 장점

이벤트 시스템의 장점을 정리하면요,

첫째, **GameManager는 렌더링 코드를 모릅니다.** 그냥 이벤트만 발행하면 됩니다.

둘째, **확장이 쉽습니다.** 새 효과를 추가하려면 리스너만 추가하면 됩니다. GameManager 코드는 수정하지 않아도 됩니다.

셋째, **테스트가 쉽습니다.** 테스트 시 모의(mock) 리스너로 대체할 수 있습니다.

---

## 9. 게임 흐름 및 상태 관리

### 9.1 상태 머신

게임의 흐름을 상태 머신으로 표현할 수 있습니다. 화면의 **상태 다이어그램**을 보시면 각 상태와 전이 조건이 명확하게 나타나 있습니다.

**START**에서 시작 버튼을 누르면 **DIFFICULTY**로 이동합니다.

**DIFFICULTY**에서 난이도를 선택하면, 미리보기 시간이 설정되어 있으면 **PREVIEW**로, 없으면 바로 **PLAYING**으로 이동합니다. 다이어그램에서 두 개의 화살표로 표현되어 있습니다.

**PREVIEW**가 끝나면 자동으로 **PLAYING**으로 이동합니다. 다이어그램 오른쪽 노트에 "모든 카드 앞면 공개"라고 표시되어 있습니다.

**PLAYING**에서는 두 가지 종료 조건이 있습니다. 모든 카드를 매칭하면 "게임 클리어", 하트가 0이 되거나 시간이 초과되면 "게임 오버"로 **RESULT**에 도달합니다.

**RESULT**에서는 "처음으로" 버튼으로 START로, "다시하기" 버튼으로 DIFFICULTY로 돌아갈 수 있습니다.

### 9.2 게임 시작 흐름

난이도를 선택하면 `gameManager.startGame(difficulty)`가 호출됩니다. 화면의 **시퀀스 다이어그램**에서 이 과정을 확인할 수 있습니다.

**사용자**가 난이도를 선택하면 **GameManager**의 startGame()이 호출됩니다.

GameManager는 먼저 **GameState**의 `reset()`을 호출해 이전 상태를 초기화하고, `setDifficulty()`로 난이도를 설정합니다.

그 다음 **CardManager**의 `createDeck()`을 호출해 카드 덱을 받아와서 GameState에 저장합니다.

그리고 **main.js**에 `emit('game:init')` 이벤트를 발행합니다.

다이어그램의 **alt 박스**를 주목해 주세요. 미리보기 시간이 설정되어 있으면 `_startPreview()` 경로로, 없으면 바로 `_startPlaying()` 경로로 진행합니다. 이런 조건부 흐름이 시퀀스 다이어그램에서 명확하게 표현됩니다.

### 9.3 카드 클릭 흐름

카드를 클릭하면 일어나는 일은 화면의 **상세 흐름도**에 나타나 있습니다. 이 흐름도는 모든 분기 조건을 보여주기 때문에 복잡해 보이지만, 하나씩 따라가 보겠습니다.

맨 위 **"사용자 카드 클릭"**에서 시작합니다. `findCardAt()`으로 카드를 찾고, `canFlip()` 분기에서 뒤집을 수 있는지 확인합니다.

그 다음 **"폭탄 카드?"** 분기가 있습니다. Yes면 `_handleBombCard()`로 페널티 처리, No면 일반 카드 뒤집기로 진행합니다.

카드를 뒤집은 후 **"첫 번째 카드?"** 분기가 있습니다. 첫 번째면 `selectFirstCard()`, 아니면 **"두 번째 카드?"** 분기로 갑니다.

두 번째 카드를 선택한 후 **"2장 매칭?"** 분기가 있습니다. 2장 매칭이면 바로 `_checkMatch()`, 3장 매칭이면 세 번째 카드를 기다립니다.

매칭 검사 후 **"매칭 성공?"** 분기가 핵심입니다. 성공하면 **초록색** `_handleMatch()` 경로로 점수와 콤보가 올라가고, 실패하면 **빨간색** `_handleMismatch()` 경로로 하트가 감소합니다.

마지막으로 **"모두 매칭?"**이나 **"하트 0?"** 분기에서 게임 종료 여부를 결정합니다.

이 흐름도를 보시면 카드 클릭 한 번에 **얼마나 많은 분기 처리**가 일어나는지 한눈에 파악할 수 있습니다.

---

## 10. 난이도 시스템

### 10.1 설정 구조

난이도 설정은 config.js의 DIFFICULTY 객체에 정의되어 있습니다.

각 난이도에는 다음 정보가 있습니다:
- name: 표시 이름
- pairs 또는 sets: 카드 쌍/세트 수
- timeLimit: 제한 시간
- gridCols, gridRows: 그리드 크기
- pointsPerMatch: 매칭 당 점수
- timePenalty: 실패 시 감소 시간
- previewTime: 미리보기 시간
- hearts: 시작 하트 수
- matchingRule: 2장 또는 3장 매칭
- specialCards: 특수 카드 설정

### 10.2 난이도별 비교

난이도를 비교하면요,

**하** 난이도는 4×2 그리드에 8장, 2장 매칭, 60초입니다.
**중** 난이도는 4×4 그리드에 16장, 2장 매칭, 90초입니다.
**상** 난이도는 8×4 그리드에 32장, 2장 매칭, 90초이고 미리보기가 없습니다.
**지옥** 난이도는 11×6 그리드에 66장, **3장 매칭**, 60초입니다.

지옥 난이도가 특이한 점은 3장을 맞춰야 한다는 것입니다. 같은 카드 3장을 연속으로 뒤집어야 매칭 성공입니다.

### 10.3 확장성

새 난이도를 추가하는 것은 매우 쉽습니다.

config.js에 설정만 추가하면 됩니다. 예를 들어 NIGHTMARE라는 새 난이도를 추가하고 싶으면, 객체 하나만 추가하면 됩니다. 게임 로직 코드는 수정할 필요가 없습니다.

matchingRule을 4로 설정하면 4장 매칭도 가능합니다. 로직이 N장 매칭을 일반화해서 처리하도록 구현되어 있기 때문입니다.

---

## 11. 특수 카드 시스템

### 11.1 폭탄 카드

**폭탄 카드**는 클릭하면 페널티를 주는 카드입니다. 화면의 **흐름도**를 보시면 폭탄 카드 클릭 시 발생하는 분기가 나타나 있습니다.

💣 폭탄 카드를 클릭하면 먼저 **1% 확률** 분기가 있습니다. 지옥 난이도에서 1%의 확률로 **💀 즉사**합니다. 게임이 바로 끝납니다.

즉사가 아니면 **3% 확률** 분기로 넘어갑니다. 3%의 확률로 **💥 카드가 섞입니다**. 아직 매칭되지 않은 카드들의 위치가 랜덤하게 바뀝니다. 외운 위치가 무효화되니까 상당히 당황스럽습니다.

둘 다 아니면 기본 페널티인 **시간 -15초**가 적용됩니다.

이 흐름도를 보시면 폭탄 카드의 **확률 기반 분기 처리**가 명확하게 이해됩니다.

### 11.2 히든 카드

**히든 카드**는 매칭에 성공하면 특별한 보너스를 주는 카드입니다. 화면의 **흐름도**를 보시면 히든 카드 매칭 시 발생하는 효과들이 나타나 있습니다.

🌟 히든 카드 매칭에 성공하면 **Effects 박스** 안의 세 가지 효과가 동시에 발생합니다:
- **황금 플래시**: 화면 전체가 황금색으로 번쩍입니다
- **화면 흔들림**: 임팩트 있는 피드백을 줍니다
- **1초간 모든 카드 공개**: 이것이 핵심입니다!

모든 카드가 잠깐 공개되는 효과 덕분에 다른 카드들의 위치를 외울 수 있습니다. 전략적으로 히든 카드를 먼저 찾는 것이 유리합니다.

이 흐름도를 보시면 히든 카드의 **보상 효과들**이 한눈에 들어옵니다.

---

## 12. 애니메이션 및 파티클 효과

### 12.1 Particle 클래스

**Particle** 클래스는 개별 파티클을 나타냅니다.

각 파티클은 위치(x, y), 속도(vx, vy), 수명(life), 크기, 모양 등의 속성을 가집니다.

`update()` 메서드에서 매 프레임마다 위치와 상태를 갱신합니다. 속도에 공기 저항을 적용하고, 중력을 더하고, 수명을 감소시킵니다.

`isDead()`는 수명이 다했거나 화면 밖으로 나갔는지 확인합니다.

### 12.2 ParticleSystem 클래스

**ParticleSystem**은 파티클들을 관리합니다.

`createMatchParticles()`는 매칭 성공 시 호출됩니다. 카드 중심에서 방사형으로 별 모양 파티클 10개가 퍼져나갑니다.

`createConfettiRain()`은 게임 클리어 시 호출됩니다. 매 5프레임마다 화면 위에서 색종이가 떨어집니다. draw() 함수에서 계속 호출되면서 연속적인 색종이 비가 내립니다.

`triggerScreenShake()`는 화면 흔들림 효과입니다. 히든 카드 매칭이나 실패 시 사용합니다. `getShakeOffset()`에서 현재 흔들림 오프셋을 계산하고, draw()에서 translate()로 전체 화면을 이동시킵니다. 시간이 지나면서 감쇠하여 자연스럽게 멈춥니다.

---

## 13. 핵심 설계 포인트 요약

마지막으로 핵심 설계 포인트를 요약하겠습니다.

### 아키텍처

**계층 분리**: Core, Logic, Rendering, Utils로 명확히 분리했습니다.
**단방향 의존**: 위 계층이 아래 계층만 참조합니다.
**관심사 분리**: 각 클래스가 하나의 책임만 담당합니다.

### 디자인 패턴

**Observer 패턴**: EventEmitter를 통한 느슨한 결합
**Factory 패턴**: CardManager의 난이도별 카드 생성
**State 패턴**: GameState.phase를 통한 상태 머신

### 코드 품질

**불변성**: ArrayUtils.shuffle()은 원본 배열을 변경하지 않습니다.
**캡슐화**: Card 클래스의 private 속성과 getter
**에러 격리**: EventEmitter에서 리스너 에러가 다른 리스너에 영향 안 줌

### 확장성

**새 난이도 추가**: config.js에 설정만 추가하면 됩니다.
**새 특수 카드 추가**: CardManager와 GameManager에 핸들러만 추가하면 됩니다.
**새 효과 추가**: 이벤트 리스너만 추가하면 됩니다.

---

## 마무리

이상으로 카드 매칭 게임의 기술적인 부분을 설명드렸습니다.

정리하면요,

- p5.js를 사용한 캔버스 기반 게임
- 계층형 아키텍처로 관심사 분리
- EventEmitter를 통한 Observer 패턴으로 느슨한 결합
- 설정 기반 난이도 시스템으로 확장성 확보
- 2장/3장 매칭과 특수 카드로 게임성 다양화

감사합니다. 질문 있으시면 말씀해 주세요.
