# 카드 매칭 게임 - 발표 대본 (10분)

---

## 1. 프로젝트 소개 (1분 30초)

안녕하세요. 지금부터 카드 매칭 게임의 기술적인 부분을 설명드리겠습니다.

이 프로젝트는 **p5.js**와 **Vanilla JavaScript**로 만든 카드 매칭 게임입니다.

**총 19개의 JavaScript 파일**로 구성되어 있고, **5개 계층**으로 분리된 구조입니다.

주요 디자인 패턴으로 **Observer**, **Factory**, **State** 패턴을 적용했습니다.

### 게임 특징 소개

이 게임의 차별화된 특징을 먼저 소개드리겠습니다.

첫째, **4단계 난이도**가 있습니다. 하(8장), 중(16장), 상(30장), 지옥(57장)으로 구성됩니다.

둘째, **특수 카드 시스템**이 있습니다. **히든 카드**는 매칭 시 모든 카드를 1초간 공개해주는 보너스 효과가 있고, **폭탄 카드**는 2번 클릭하면 즉시 게임 오버되는 긴장감 요소입니다.

셋째, **지옥 모드**에서는 2장이 아닌 **3장 매칭** 규칙이 적용됩니다.

지금부터 **p5.js 기능 활용**과 핵심 설계를 다이어그램과 함께 설명드리겠습니다.

---

## 2. p5.js 게임 루프 (2분)

### 게임의 심장

이 프로젝트에서 가장 핵심적인 p5.js 기능은 **게임 루프**입니다.

코드를 보시면, `setup()` 함수에서 **createCanvas**로 1280x720 캔버스를 만들고, **imageMode(CENTER)**로 이미지 기준점을 중앙으로 설정합니다.

`draw()` 함수는 **초당 60번** 자동 호출됩니다. 매번 `background()`로 화면을 지우고 새로 그리는 방식으로 애니메이션을 구현합니다.

사용자 입력은 **mouseClicked()**, **keyPressed()** 같은 이벤트 핸들러로 처리합니다.

### 카드 뒤집기 효과

카드 뒤집기 애니메이션에서 p5.js의 **변환 함수**를 활용했습니다.

`push()`와 `pop()`으로 변환 상태를 저장하고 복원합니다. 이렇게 하면 한 카드의 변환이 다른 카드에 영향을 주지 않습니다.

`translate()`로 좌표계를 카드 중심으로 이동하고, `scale(cos(progress * PI), 1)`로 **X축 스케일**을 조절합니다.

**cos 함수**를 사용하면 1에서 0으로, 다시 -1로 갔다가 0으로 돌아오는 곡선이 만들어집니다. 이것이 **3D 뒤집기 효과**를 만듭니다.

### 파티클 시스템

매칭 성공 시 나타나는 파티클 효과도 p5.js 기능으로 구현했습니다.

`random()`으로 파티클의 속도와 방향을 랜덤하게 설정하고, `lerpColor()`로 시작 색상에서 끝 색상으로 **부드럽게 전환**합니다.

`ellipse()`로 원형 파티클을 그리고, `millis()`로 시간을 측정해서 **시간 기반 애니메이션**을 구현합니다.

---

## 3. 아키텍처 & 클래스 설계 (2분)

### 계층형 아키텍처

화면의 다이어그램을 보시면 **5개의 계층**이 색상별로 구분되어 있습니다.

맨 위 **파란색 Presentation Layer**는 main.js로, p5.js의 setup, draw, 이벤트를 담당합니다.

그 아래 **주황색 Rendering Layer**는 UIRenderer, CardRenderer, ParticleSystem으로 화면을 그리는 역할입니다.

**보라색 Logic Layer**는 GameManager와 CardManager로, 게임 규칙과 매칭 로직을 처리합니다. 여기서 **GameManager는 EventEmitter를 상속**받아 이벤트를 발행할 수 있습니다.

**초록색 Core Layer**는 GameState와 Card 클래스로, 데이터 모델을 담당합니다. **GameState는 State 패턴**으로 게임 상태를 관리합니다.

마지막 **분홍색 Utils Layer**는 EventEmitter, SoundManager, HighScoreManager 같은 공통 유틸리티입니다.

### 핵심 설계 원칙

다이어그램의 **화살표 방향**을 보시면 모두 위에서 아래로 향합니다. 이것이 **단방향 의존성**의 핵심입니다.

또한 **점선 화살표**로 표시된 부분이 있는데, 이는 GameManager가 EventEmitter를 **상속(extends)**하는 관계입니다.

**실선 화살표**는 uses, creates 같은 **사용 관계**를 나타냅니다. CardManager가 Card를 **생성(creates)**하고, GameManager가 GameState를 **사용(uses)**합니다.

### 디자인 패턴 적용

표에 정리된 것처럼 **Observer 패턴**은 EventEmitter에서 GameManager로, **Factory 패턴**은 CardManager의 createDeck에, **State 패턴**은 GameState.phase에 적용했습니다.

---

## 4. 이벤트 시스템 (1분 30초)

### Observer 패턴

**EventEmitter**는 Observer 패턴을 구현한 클래스입니다.

코드를 보시면, `on()` 메서드로 이벤트를 **구독**하고, `emit()` 메서드로 이벤트를 **발행**합니다.

중요한 점은 emit()에서 각 리스너를 **try-catch**로 감싸고 있다는 것입니다. 이렇게 하면 한 리스너에서 에러가 발생해도 다른 리스너에는 영향을 주지 않습니다.

### 이벤트 흐름

화면의 **시퀀스 다이어그램**을 보시면 이벤트가 어떻게 전파되는지 확인할 수 있습니다.

**사용자**가 카드를 클릭하면 **GameManager**가 **GameState**를 업데이트하고, `emit('match:success')`로 이벤트를 발행합니다.

**점선 화살표**를 주목해 주세요. GameManager에서 main.js로 이벤트가 전달되고, main.js가 CardRenderer, ParticleSystem, SoundManager를 각각 호출합니다.

이것이 **Observer 패턴의 핵심**입니다. **GameManager는 렌더링 코드를 전혀 모릅니다.** 이벤트만 발행하면 됩니다.

### 주요 이벤트

표를 보시면 주요 이벤트들이 정리되어 있습니다. 특히 **hidden:match** 이벤트는 히든 카드 매칭 시 발생하는데, 금색 플래시와 함께 전체 카드를 공개하는 특수 효과를 트리거합니다.

---

## 5. 카드 클릭 흐름 (2분)

카드를 클릭하면 일어나는 일은 화면의 **상세 흐름도**에 나타나 있습니다.

### 기본 흐름

맨 위 **"사용자 카드 클릭"**에서 시작해서 하나씩 따라가 보겠습니다.

먼저 `findCardAt()`으로 카드를 찾고, **canFlip() 분기**에서 뒤집을 수 있는지 확인합니다.

### 특수 카드 분기

그 다음 **"카드 종류?"** 분기가 있습니다.

**노란색 히든 카드**는 매칭 시 모든 카드를 1초간 공개해주는 **역전 찬스**입니다.

**주황색 폭탄 카드**는 2번 클릭하면 **즉시 게임 오버**됩니다. 상/지옥 난이도에서만 등장하며, 긴장감을 더해줍니다.

### 매칭 규칙

일반 카드를 뒤집은 후 **"매칭 규칙?"** 분기가 있습니다.

하/중/상 난이도에서는 **2장 매칭**, 지옥 모드에서는 **3장 매칭**입니다. 지옥 모드에서 3장을 모두 맞춰야 성공입니다.

### 매칭 결과

**"매칭 성공?"** 분기가 핵심입니다.

성공하면 **초록색** `handleMatch` 경로로 카드가 매칭 처리됩니다.

실패하면 **빨간색** `handleMismatch` 경로로 하트가 감소합니다.

### 게임 종료

마지막으로 **"모두 매칭?"**이면 게임 클리어와 함께 엔딩 크레딧이 표시되고, **"하트 0?"**이면 게임 오버로 끝납니다.

이 흐름도를 보시면 카드 클릭 한 번에 **얼마나 많은 분기 처리**가 일어나는지 한눈에 파악할 수 있습니다.

---

## 6. 핵심 요약 (1분)

마지막으로 핵심을 정리하겠습니다.

### 아키텍처

**계층 분리**로 관심사를 분리하고, **단방향 의존**으로 의존성을 명확하게 했습니다.

### 디자인 패턴

**Observer 패턴**으로 느슨한 결합, **Factory 패턴**으로 난이도별 카드 생성, **State 패턴**으로 게임 상태 머신을 구현했습니다.

### p5.js 활용

**게임 루프**는 setup()과 draw()로 60fps 렌더링, **변환 함수**로 카드 뒤집기 효과, **파티클 시스템**으로 시각적 피드백을 구현했습니다.

### 게임 차별화 포인트

**히든 카드**로 역전 찬스를, **폭탄 카드**로 긴장감을, **3장 매칭**으로 고난도 도전을 구현했습니다.

---

## 마무리

이상으로 카드 매칭 게임의 기술적인 부분을 설명드렸습니다.

정리하면요,

- **p5.js 핵심 기능**: setup/draw 루프, 변환 함수, 애니메이션
- **5계층 아키텍처** (단방향 의존)
- **Observer 패턴** (느슨한 결합)
- **특수 카드 시스템** (히든/폭탄/3장매칭)

감사합니다. 질문 있으시면 말씀해 주세요.
